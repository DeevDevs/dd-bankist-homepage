{"mappings":"AAAA,aAIA,MAAMA,OAASC,SAASC,cAAc,WAChCC,MAAQF,SAASC,cAAc,UAC/BE,QAAUH,SAASC,cAAc,YACjCG,cAAgBJ,SAASC,cAAc,qBACvCI,cAAgBL,SAASM,iBAAiB,oBAC1CC,YAAcP,SAASC,cAAc,mBACrCO,SAAWR,SAASC,cAAc,eAClCQ,GAAKT,SAASC,cAAc,MAE5BS,OAASV,SAASM,iBAAiB,UACnCK,QAAUX,SAASC,cAAc,sBACjCW,SAAWZ,SAASC,cAAc,uBAClCY,cAAgBb,SAASC,cAAc,SACvCa,gBAAkBd,SAASM,iBAAiB,YAC5CS,gBAAkBf,SAASM,iBAAiB,kBAE5CU,kBAAoB,WACxBD,gBAAgBE,SAAQ,CAACC,EAAIC,KAC3B,MAAMC,EAAiBN,gBAAgBK,GAAGE,IAAIC,MAAM,KACpDJ,EAAGK,QAAQF,IAAMD,EAAeA,EAAeI,OAAS,OAItDC,UAAY,SAAUC,GAC1BA,EAAEC,iBACFzB,MAAM0B,UAAUC,OAAO,UACvB1B,QAAQyB,UAAUC,OAAO,WAGrBC,WAAa,WACjB5B,MAAM0B,UAAUG,IAAI,UACpB5B,QAAQyB,UAAUG,IAAI,WAMxB1B,cAAcY,SAAQe,GAAOA,EAAIC,iBAAiB,QAASR,aAE3DrB,cAAc6B,iBAAiB,QAASH,YACxC3B,QAAQ8B,iBAAiB,QAASH,YAElC9B,SAASiC,iBAAiB,WAAW,SAAUP,GAC/B,WAAVA,EAAEQ,KAAqBhC,MAAM0B,UAAUO,SAAS,WAClDL,gBAKJvB,YAAY0B,iBAAiB,SAAS,SAAUP,GAC9ClB,SAAS4B,eAAe,CAAEC,SAAU,cAMtCrC,SAASC,cAAc,eAAegC,iBAAiB,SAAS,SAAUP,GACxEA,EAAEC,iBAGAD,EAAEY,OAAOV,UAAUO,SAAS,eAC3BT,EAAEY,OAAOV,UAAUO,SAAS,oBAE7BnC,SACGC,cAAcyB,EAAEY,OAAOC,aAAa,SACpCH,eAAe,CAAEC,SAAU,cAKlC,MAAMG,KAAOxC,SAASM,iBAAiB,oBACjCmC,cAAgBzC,SAASC,cAAc,8BACvCyC,YAAc1C,SAASM,iBAAiB,wBAE9CmC,cAAcR,iBAAiB,SAAS,SAAUP,GAChD,MAAMiB,EAAUjB,EAAEY,OAAOM,QAAQ,oBAE5BD,IAELD,YAAYzB,SAAQ4B,GAClBA,EAAMjB,UAAUC,OAAO,iCAEzBW,KAAKvB,SAAQ6B,GAAOA,EAAIlB,UAAUC,OAAO,6BAGzCc,EAAQf,UAAUG,IAAI,2BAEtB/B,SACGC,cAAc,yBAAyB0C,EAAQpB,QAAQuB,OACvDlB,UAAUG,IAAI,mCAInB,MAAMgB,IAAM/C,SAASC,cAAc,QAE7B+C,aAAe,SAAUtB,GAC7B,GAAIA,EAAEY,OAAOV,UAAUO,SAAS,aAAc,CAC5C,MAAMc,EAAOvB,EAAEY,OACTY,EAAWD,EAAKL,QAAQ,QAAQtC,iBAAiB,cACjD6C,EAAOF,EAAKL,QAAQ,QAAQ3C,cAAc,OAChDiD,EAASjC,SAAQC,IACXA,IAAO+B,IAAM/B,EAAGkC,MAAMC,QAAUC,MACpCH,EAAKC,MAAMC,QAAUC,UAY3BP,IAAId,iBAAiB,YAAae,aAAaO,KAAK,KACpDR,IAAId,iBAAiB,WAAYe,aAAaO,KAAK,IAUnD,MAAMC,UAAYT,IAAIU,wBAAwBC,OACxCC,YAAc,SAAUC,GAK5B,MAAOC,GAASD,EACXC,EAAMC,eAENf,IAAInB,UAAUC,OAAO,UAFCkB,IAAInB,UAAUG,IAAI,WAIzCgC,WAAa,CACjBC,KAAM,KACNC,UAAW,EACXC,WAAY,IAAIV,eAEZW,eAAiB,IAAIC,qBAAqBT,YAAaI,YAC7DI,eAAeE,QAAQtE,QAGvB,MAAMuE,YAActE,SAASM,iBAAiB,YAExCiE,cAAgB,SAAUX,EAASY,GACvC,MAAOX,GAASD,EACXC,EAAMC,iBACXD,EAAMvB,OAAOV,UAAUC,OAAO,mBAC9B2C,EAASC,UAAUZ,EAAMvB,UAErBoC,gBAAkB,IAAIN,qBAAqBG,cAAe,CAC9DP,KAAM,KACNC,UAAW,MAEbK,YAAYrD,SAAQ,SAAU0D,GAC5BA,EAAQ/C,UAAUG,IAAI,mBACtB2C,gBAAgBL,QAAQM,MAK1B,MAAMC,WAAa5E,SAASM,iBAAiB,iBAEvCuE,YAAc,SAAUjB,EAASY,GACrC,MAAOX,GAASD,EACXC,EAAMC,iBAGXD,EAAMvB,OAAOjB,IAAMwC,EAAMvB,OAAOf,QAAQF,IAGxCwC,EAAMvB,OAAOL,iBAAiB,QAAQ,WACpC4B,EAAMvB,OAAOV,UAAUC,OAAO,eAIhC2C,EAASC,UAAUZ,EAAMvB,UAGrBwC,YAAc,IAAIV,qBAAqBS,YAAa,CACxDb,KAAM,KACNC,UAAW,EACXC,WAAY,UAEdU,WAAW3D,SAAQ,SAAU8D,GAC3BD,YAAYT,QAAQU,MAItBrE,OAAOO,SAAQ,CAAC+D,EAAG7D,IAAO6D,EAAE5B,MAAM6B,UAAY,cAAc,IAAM9D,QAKlE,IAAI+D,SAAW,EAGf,MAAMC,WAAa,WACjBzE,OAAOO,SAAQ,SAAUmE,EAAGjE,GAC1BN,cAAcwE,mBACZ,YACA,yCAAyClE,oBAMzCmE,UAAY,SAAUC,GAC1B7E,OAAOO,SACL,CAAC+D,EAAG7D,IAAO6D,EAAE5B,MAAM6B,UAAY,cAAc,KAAO9D,EAAIoE,SAE1DC,YAAYN,WAGRO,UAAY,WAEhBP,SAAWxE,OAAOc,OAAS,EAAI0D,WAAcA,SAAW,EAExDI,UAAUJ,WAGNQ,UAAY,WAChBR,SAAW,EAAIA,WAAcA,SAAWxE,OAAOc,OAAS,EACxD8D,UAAUJ,WAGNM,YAAc,SAAUD,GAC5BvF,SAASM,iBAAiB,cAAcW,SAAQ,SAAU0E,GACxDA,EAAI/D,UAAUC,OAAO,qBAErB7B,SACGC,cAAc,0BAA0BsF,OACxC3D,UAAUG,IAAI,yBAMf6D,KAAO,WAxCXlF,OAAOO,SAAQ,SAAUmE,EAAGjE,GAC1BN,cAAcwE,mBACZ,YACA,yCAAyClE,mBAuC7CqE,YAAYN,UAlOZnE,gBAAgBE,SAAQ,CAACC,EAAIC,KAC3B,MAAMC,EAAiBN,gBAAgBK,GAAGE,IAAIC,MAAM,KACpDJ,EAAGK,QAAQF,IAAMD,EAAeA,EAAeI,OAAS,OAqO5DZ,SAASqB,iBAAiB,QAASwD,WACnC9E,QAAQsB,iBAAiB,QAASyD,WAGlC1F,SAASiC,iBAAiB,WAAW,SAAUP,GAC/B,cAAVA,EAAEQ,KAAqBwD,YACjB,eAAVhE,EAAEQ,KAAwBuD,eAI5B5E,cAAcoB,iBAAiB,SAAS,SAAUP,GAC3CA,EAAEY,OAAOV,UAAUO,SAAS,eACjC+C,SAAWxD,EAAEY,OAAOf,QAAQsE,MAK5BP,UAAUJ,cAhEVxE,OAAOO,SAAQ,SAAUmE,EAAGjE,GAC1BN,cAAcwE,mBACZ,YACA,yCAAyClE,mBAuC7CqE,YAAYN,UAlOZnE,gBAAgBE,SAAQ,CAACC,EAAIC,KAC3B,MAAMC,EAAiBN,gBAAgBK,GAAGE,IAAIC,MAAM,KACpDJ,EAAGK,QAAQF,IAAMD,EAAeA,EAAeI,OAAS","sources":["script.js"],"sourcesContent":["'use strict';\n\n///////////////////////////////////////\n// Modal window\nconst header = document.querySelector('.header');\nconst modal = document.querySelector('.modal');\nconst overlay = document.querySelector('.overlay');\nconst btnCloseModal = document.querySelector('.btn--close-modal');\nconst btnsOpenModal = document.querySelectorAll('.btn--show-modal');\nconst btnScrollTo = document.querySelector(`.btn--scroll-to`);\nconst section1 = document.querySelector('#section--1');\nconst h1 = document.querySelector('h1');\n//Variables for Slides\nconst slides = document.querySelectorAll('.slide');\nconst btnLeft = document.querySelector('.slider__btn--left');\nconst btnRight = document.querySelector('.slider__btn--right');\nconst dotsContainer = document.querySelector('.dots');\nconst invisibleImages = document.querySelectorAll('.img-set');\nconst imagesToReplace = document.querySelectorAll('.features__img');\n\nconst addingImagesPaths = function () {\n  imagesToReplace.forEach((el, i) => {\n    const splittedString = invisibleImages[i].src.split('/');\n    el.dataset.src = splittedString[splittedString.length - 1];\n  });\n};\n\nconst openModal = function (e) {\n  e.preventDefault();\n  modal.classList.remove('hidden');\n  overlay.classList.remove('hidden');\n};\n\nconst closeModal = function () {\n  modal.classList.add('hidden');\n  overlay.classList.add('hidden');\n};\n\n//opening/closing the Modal Window\n// for (let i = 0; i < btnsOpenModal.length; i++)\n//   btnsOpenModal[i].addEventListener('click', openModal); Let us use forEach instead\nbtnsOpenModal.forEach(btn => btn.addEventListener('click', openModal));\n\nbtnCloseModal.addEventListener('click', closeModal);\noverlay.addEventListener('click', closeModal);\n\ndocument.addEventListener('keydown', function (e) {\n  if (e.key === 'Escape' && !modal.classList.contains('hidden')) {\n    closeModal();\n  }\n});\n\n// SMOOTH SCROLLING to the section 1\nbtnScrollTo.addEventListener('click', function (e) {\n  section1.scrollIntoView({ behavior: 'smooth' });\n});\n\n// SMOOTH SCROLLING FROM ALL NAV BUTTONS - Event Delegation\n//1. add eventListener to common parent element\n//2. Determine, what element originated the event (e.target)\ndocument.querySelector('.nav__links').addEventListener('click', function (e) {\n  e.preventDefault();\n  //below, we check if the element we are clicking containts the class needed. Otherwise, the entire parent element activates the scrolling and creates an error\n  if (\n    e.target.classList.contains('nav__link') &&\n    !e.target.classList.contains('btn--show-modal')\n  ) {\n    document\n      .querySelector(e.target.getAttribute('href'))\n      .scrollIntoView({ behavior: 'smooth' });\n  }\n});\n\n// BUILDING A TABBED COMPONENT\nconst tabs = document.querySelectorAll('.operations__tab');\nconst tabsContainer = document.querySelector('.operations__tab-container');\nconst tabsContent = document.querySelectorAll('.operations__content');\n\ntabsContainer.addEventListener('click', function (e) {\n  const clicked = e.target.closest('.operations__tab');\n  //Guard Clause - used to terminate function, if needed\n  if (!clicked) return;\n  //Before activating the tab and the content window, I remove the active class from all of them to assign it to the ones I need\n  tabsContent.forEach(child =>\n    child.classList.remove('operations__content--active')\n  );\n  tabs.forEach(tab => tab.classList.remove('operations__tab--active'));\n\n  //Activating the tab\n  clicked.classList.add('operations__tab--active');\n  //Activating content - I used the data-tab attribute through dataset to find the window\n  document\n    .querySelector(`.operations__content--${clicked.dataset.tab}`)\n    .classList.add('operations__content--active');\n});\n\n// MENU FADE ANIMATION\nconst nav = document.querySelector('.nav');\n\nconst hoverHandler = function (e) {\n  if (e.target.classList.contains('nav__link')) {\n    const link = e.target;\n    const siblings = link.closest('.nav').querySelectorAll('.nav__link');\n    const logo = link.closest('.nav').querySelector('img');\n    siblings.forEach(el => {\n      if (el !== link) el.style.opacity = this;\n      logo.style.opacity = this;\n    });\n  }\n}; //we use mouseover because it bubbles, while mouseenter doesn't\n\n// nav.addEventListener('mouseover', function (e) {\n//   hoverHandler(e, 0.5);\n// });\n// nav.addEventListener('mouseout', function (e) {\n//   hoverHandler(e, 1);\n// });\n//instead of putting the function inside and make it look ugly, we can use the BIND method and pass the 'argument' into the handler. we just leave the 'e' argument in the initial function, and use THIS in the opacity (Read More)\nnav.addEventListener('mouseover', hoverHandler.bind(0.5));\nnav.addEventListener('mouseout', hoverHandler.bind(1));\n\n// STICKY NAVIGATION EFFECT just for the section 1 (old version)\n// const initialCoords = section1.getBoundingClientRect();\n// window.addEventListener('scroll', function () {\n//   if (window.scrollY > initialCoords.top) nav.classList.add('sticky');\n//   else nav.classList.remove('sticky');\n// });\n\n// STICKY NAVIGATION: Intersection Observer API\nconst navHeight = nav.getBoundingClientRect().height;\nconst obsCallback = function (entries) {\n  // nav.classList.contains('sticky')\n  //   ? nav.classList.add('sticky')\n  //   : nav.classList.remove('sticky');\n  //OR\n  const [entry] = entries; // this is how I select ONE entry of the entries (here it is always one)\n  if (!entry.isIntersecting) nav.classList.add('sticky');\n  // isIntersecting is a property of the entry\n  else nav.classList.remove('sticky');\n}; // It is called with two arguments\nconst obsOptions = {\n  root: null,\n  threshold: 0,\n  rootMargin: `-${navHeight}px`, // This is to modify the treshold slightly. E.g. here it shows that I want the function to be called navHeight BEFORE the end of the Header intersection\n}; // Also, I can insert it directly into the arguments below\nconst headerObserver = new IntersectionObserver(obsCallback, obsOptions);\nheaderObserver.observe(header);\n\n// REVEAL SECTIONS using Intersection Observer API\nconst allSections = document.querySelectorAll('.section');\n\nconst revealSection = function (entries, observer) {\n  const [entry] = entries; // here we get just one entry out of entries\n  if (!entry.isIntersecting) return;\n  entry.target.classList.remove('section--hidden'); // To make that only section reveal, which I am looking at...\n  observer.unobserve(entry.target); // To stop obsering the section which has already been revealed (for the sake of the performance)\n};\nconst sectionObserver = new IntersectionObserver(revealSection, {\n  root: null,\n  threshold: 0.15,\n});\nallSections.forEach(function (section) {\n  section.classList.add('section--hidden');\n  sectionObserver.observe(section);\n});\n\n//LAZY LOADING IMAGES\n\nconst imgTargets = document.querySelectorAll('img[data-src]'); // This is how we use only the images that have the data-src attribute (have higher resolution versions)\n\nconst revealImage = function (entries, observer) {\n  const [entry] = entries;\n  if (!entry.isIntersecting) return;\n\n  //replace src with data-src\n  entry.target.src = entry.target.dataset.src;\n\n  //Instead of removing the lazy-img class immediately, better to wait for the picture loading is over, and then only remove the class. Let us use the EventListener\n  entry.target.addEventListener('load', function () {\n    entry.target.classList.remove('lazy-img');\n  });\n\n  //stop observing\n  observer.unobserve(entry.target);\n};\n\nconst imgObserver = new IntersectionObserver(revealImage, {\n  root: null,\n  threshold: 0,\n  rootMargin: '200px', // This parameter makes the images load 200px BEFORE they reach the root (viewport)\n});\nimgTargets.forEach(function (img) {\n  imgObserver.observe(img);\n});\n\n//here we place each of the slides in one row\nslides.forEach((s, i) => (s.style.transform = `translateX(${100 * i}%)`));\n\n//---- here we create functions for the buttons ----\n\n//common variable for most of the functions below\nlet curSlide = 0;\n\n//This is how we create the dots for slides\nconst createDots = function () {\n  slides.forEach(function (_, i) {\n    dotsContainer.insertAdjacentHTML(\n      'beforeend',\n      `<button class=\"dots__dot\" data-slide=\"${i}\"></button>`\n    );\n  });\n};\n\n// this is a general sliding function\nconst goToSlide = function (cuS) {\n  slides.forEach(\n    (s, i) => (s.style.transform = `translateX(${100 * (i - cuS)}%)`)\n  );\n  activateDot(curSlide);\n};\n\nconst nextSlide = function () {\n  //first we check if we have reached the last slide. If yes, we jump back to the first one\n  curSlide < slides.length - 1 ? curSlide++ : (curSlide = 0);\n  // then we use that value, to move the slides horizontally\n  goToSlide(curSlide);\n};\n\nconst prevSlide = function () {\n  curSlide > 0 ? curSlide-- : (curSlide = slides.length - 1);\n  goToSlide(curSlide);\n};\n\nconst activateDot = function (cuS) {\n  document.querySelectorAll('.dots__dot').forEach(function (dot) {\n    dot.classList.remove('dots__dot--active');\n    //Here we choose the slide that should be active\n    document\n      .querySelector(`.dots__dot[data-slide=\"${cuS}\"]`)\n      .classList.add('dots__dot--active');\n    //OR\n    // if (dot.dataset.slide === `${cuS}`) dot.classList.add('dots__dot--active');\n  });\n};\n//This is the function that we need to run at the page refresh to create/activate Dots\nconst init = function () {\n  createDots();\n  activateDot(curSlide);\n  addingImagesPaths();\n};\n\n// -------- Event handlers --------\nbtnRight.addEventListener('click', nextSlide);\nbtnLeft.addEventListener('click', prevSlide);\n\n// Go to Slide using keyboard Arrows\ndocument.addEventListener('keydown', function (e) {\n  if (e.key === 'ArrowLeft') prevSlide(); // Notice that I can use either IF\n  e.key === 'ArrowRight' && nextSlide(); // or Short Circuit... both work just fine\n});\n\n//here we do Event Delegation to make dots work\ndotsContainer.addEventListener('click', function (e) {\n  if (!e.target.classList.contains('dots__dot')) return;\n  curSlide = e.target.dataset.slide;\n  // OR ... below is the example of DESTRUCTURING (Read More)\n  // const { slide } = e.target.dataset;\n  // console.log(slide);\n\n  goToSlide(curSlide);\n});\n\n//creating and activating dots at page load\ninit();\n\n// LIFECYCLE DOM EVENTS\n// DOMContentLoaded is an event, when the HTML DOM tree and the initial JS Script are loaded and executed\n// document.addEventListener('DOMContentLoaded', function (e) {\n//   console.log('HTML parsed and DOM tree built!', e);\n// });\n\n// // Load is an event, when all the sections and images are loaded.\n// window.addEventListener('load', function (e) {\n//   console.log('Page fully loaded!', e);\n// });\n"],"names":["header","document","querySelector","modal","overlay","btnCloseModal","btnsOpenModal","querySelectorAll","btnScrollTo","section1","h1","slides","btnLeft","btnRight","dotsContainer","invisibleImages","imagesToReplace","addingImagesPaths","forEach","el","i","splittedString","src","split","dataset","length","openModal","e","preventDefault","classList","remove","closeModal","add","btn","addEventListener","key","contains","scrollIntoView","behavior","target","getAttribute","tabs","tabsContainer","tabsContent","clicked","closest","child","tab","nav","hoverHandler","link","siblings","logo","style","opacity","this","bind","navHeight","getBoundingClientRect","height","obsCallback","entries","entry","isIntersecting","obsOptions","root","threshold","rootMargin","headerObserver","IntersectionObserver","observe","allSections","revealSection","observer","unobserve","sectionObserver","section","imgTargets","revealImage","imgObserver","img","s","transform","curSlide","createDots","_","insertAdjacentHTML","goToSlide","cuS","activateDot","nextSlide","prevSlide","dot","init","slide"],"version":3,"file":"index.80a00a3e.js.map"}